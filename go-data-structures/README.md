# Go 常用数据结构实战

本项目专注于 Go 语言内置的核心数据结构，并通过一系列示例代码，深入讲解它们的特性、用法和最佳实践。

## 项目结构

```
/go-data-structures
├── slices/                # 切片 (Slice) 示例
│   └── slice_examples.go
├── maps/                  # 映射 (Map) 示例
│   └── map_examples.go
├── structs/               # 结构体 (Struct) 示例
│   └── struct_examples.go
├── sets/                  # 集合 (Set) 的实现示例
│   └── set_examples.go
├── main.go                # 项目主入口，调用所有示例
└── go.mod
```

## 如何运行示例

直接运行 `main.go` 即可。程序会自动按顺序执行所有数据结构的演示函数。

```sh
go run main.go
```

---

## 示例详解

### 1. 切片 (`slices/`)

切片（Slice）是 Go 中最重要、最常用的数据结构之一。它是一个**动态数组**，提供了比数组更强大的功能和便利性。

*   **核心概念**: 切片本身不存储任何数据，它只是一个指向底层数组的**视图**。一个切片由三个部分组成：一个指向底层数组的指针、一个长度（length）和一个容量（capacity）。
    *   **长度 (len)**: 切片中元素的数量。
    *   **容量 (cap)**: 从切片的起始元素到底层数组末尾的元素数量。
*   **`append`**: 当你使用 `append` 添加元素时，如果切片的容量不足，Go 会自动创建一个新的、更大的底层数组，并将所有元素复制过去。这就是切片能够动态增长的原理。
*   **切片的切片**: 当你从一个切片中创建另一个切片时（如 `s[2:5]`），它们最初会共享同一个底层数组。这意味着，如果你修改了子切片中的元素，原始切片中对应的元素也会被改变。要创建完全独立的切片，必须使用 `copy()` 函数。

### 2. 映射 (`maps/`)

映射（Map）是用于存储键值对的无序集合。

*   **`make` 函数**: 必须使用 `make(map[keyType]valueType)` 来创建和初始化一个 map。一个未初始化的 map 的零值是 `nil`，你不能向一个 `nil` map 中添加键值对。
*   **“comma ok” 用法**: 在读取 map 时，你应该总是使用 `value, ok := m[key]` 的形式。如果键存在，`ok` 会是 `true`；如果不存在，`ok` 会是 `false`，而 `value` 会是该类型的零值。这可以帮助你区分“键存在但值为零值”和“键根本不存在”这两种情况。
*   **无序性**: 遍历 map 的顺序是**不保证**的。每次 `for...range` 遍历，你得到的键值对顺序都可能不同。

### 3. 结构体 (`structs/`)

结构体（Struct）是一个字段的集合，用于将相关的数据组织在一起，形成自定义的复杂数据类型。

*   **方法 (Methods)**: Go 允许你为自定义类型（包括结构体）附加函数，我们称之为方法。方法通过一个特殊的“接收者”参数与类型关联起来。
*   **值接收者 vs. 指针接收者**: `func (p Person) Introduce()` 是一个值接收者，它在方法内部操作的是 `Person` 对象的一个副本，因此无法修改原始对象。`func (p *Person) HaveBirthday()` 是一个指针接收者，它操作的是对象的指针，因此可以修改原始对象的值。通常，如果方法需要修改接收者的状态，或者结构体本身很大（为了避免复制的开销），我们应该使用指针接收者。

### 4. 集合的实现 (`sets/`)

Go 语言没有内置的 `Set` 数据结构，但我们可以非常容易地使用 `map` 来实现一个。

*   **`map[string]struct{}`**: 这是实现 `Set` 的最佳方式。我们只关心 `map` 的键（key）是否存在，而值（value）是无用的。`struct{}` 是一个空结构体，它在 Go 中是一个**零内存占用**的值。因此，使用 `map[string]struct{}` 比使用 `map[string]bool` 更节省内存，更能清晰地表达“我们只关心键”的意图。
*   **实现**: 示例中展示了如何围绕这个 `map` 类型创建 `Add`, `Remove`, `Contains` 和 `List` 等方法，从而封装出一个功能完整的 `Set` 类型。
