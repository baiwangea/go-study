# Go 语言常用算法实现

本项目旨在使用 Go 语言实现一系列经典的计算机科学算法，并提供清晰、详细的讲解，帮助你理解算法的核心思想和实现细节。

## 项目结构

```
/go-algorithms
├── sorting/                 # 排序算法
│   ├── bubble_sort.go
│   └── quick_sort.go
├── main.go                  # 项目主入口，用于运行和演示算法
├── go.mod
└── README.md
```

## 如何运行示例

直接运行 `main.go` 即可。程序会自动按顺序执行所有已实现的算法演示。

```sh
go run main.go
```

---

## 算法详解

### 排序算法 (`sorting/`)

#### 1. 冒泡排序 (Bubble Sort)

*   **核心思想**: 重复地遍历待排序的列表，每次比较相邻的两个元素，如果它们的顺序错误就把它们交换过来。遍历列表的工作会重复地进行，直到没有再需要交换的元素为止，这意味着列表已经排序完成。
*   **过程**: 就像气泡一样，每一轮遍历都会将当前未排序部分的最大（或最小）元素“冒泡”到列表的末尾。
*   **时间复杂度**: 
    *   最坏情况: O(n²)
    *   平均情况: O(n²)
    *   最好情况: O(n) (如果加入一个标志位来检测某轮遍历是否发生交换)
*   **评价**: 冒泡排序是所有排序算法中最简单直观的一种，但由于其时间复杂度为 O(n²)，在数据量较大时效率极低，因此在实际生产中很少使用。它主要用于教学目的。

#### 2. 快速排序 (Quick Sort)

*   **核心思想**: 采用“分而治之”的策略。它选择一个元素作为“基准”(pivot)，然后重新排序数组，所有小于基准的元素都移动到基准的左边，所有大于基准的元素都移动到基准的右边。这个过程称为“分区”(partition)。之后，再递归地对基准左右两边的子数组进行快速排序。
*   **过程**:
    1.  **选择基准**: 从数组中选择一个元素作为基准（本例中选择最后一个元素）。
    2.  **分区**: 重新排列数组，使得所有小于等于基准的元素都在其左侧，所有大于基准的元素都在其右侧。基准元素此时处于其最终排序位置。
    3.  **递归**: 对基准左侧和右侧的两个子数组重复上述过程。
*   **时间复杂度**:
    *   最坏情况: O(n²) (发生在数组已经基本有序或逆序，导致每次分区都极不均衡)
    *   平均情况: O(n log n)
    *   最好情况: O(n log n)
*   **评价**: 快速排序是实践中应用最广泛的排序算法之一。它的平均时间复杂度非常优秀，并且是“原地排序”（in-place），空间复杂度仅为 O(log n)（递归栈的深度）。
