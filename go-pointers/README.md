# Go 语言指针 (Pointers) 详解

本项目通过一个集中的示例，深入讲解 Go 语言中指针的核心概念，以及“值传递”与“指针传递”的根本区别。

## 如何运行示例

直接运行 `main.go` 即可。

```sh
go run main.go
```

程序将演示通过值传递和指针传递修改变量的不同结果，并展示指针的基本用法。

---

## 核心概念详解

### 什么是指针？

简单来说，一个指针是一个存储了**另一个变量内存地址**的变量。它就像一个门牌号，通过这个号，你可以直接找到并操作那栋房子（内存）里的东西。

### 关键操作符

1.  **`&` (取地址符)**
    *   当你将 `&` 放在一个变量前面（如 `&i`），它会返回该变量在内存中的地址。这个结果就是一个指针。

2.  **`*` (解引用符)**
    *   当你将 `*` 放在一个指针变量前面（如 `*p`），它会返回该指针所指向的内存地址上存储的**实际值**。
    *   你也可以通过解引用来**修改**该地址上的值，如 `*p = 0`。

### 值传递 (Pass by Value) vs. 指针传递 (Pass by Pointer)

这是理解指针最关键的应用场景。

*   **值传递 (`zeroVal` 函数)**:
    *   当你将一个变量（如 `i`）作为参数传递给一个函数时，Go 默认会**复制**这个变量的值，然后将副本传递给函数。
    *   函数内部对这个副本的任何修改，都**不会**影响到函数外部的原始变量。这就是为什么在调用 `zeroVal(i)` 后，`i` 的值没有改变。

*   **指针传递 (`zeroPtr` 函数)**:
    *   当你将一个变量的内存地址（一个指针，如 `&i`）传递给函数时，函数同样会复制这个参数，但它复制的是**地址**。
    *   这意味着，函数内部的指针和外部的指针都指向**同一个内存地址**。
    *   当函数内部通过解引用操作符 `*` 来修改该地址上的值时（`*iptr = 0`），它修改的是原始变量 `i` 所在的内存，因此原始变量 `i` 的值被永久改变了。

### 为什么使用指针？

1.  **修改函数外部的变量**: 如上所示，如果你希望一个函数能够修改其调用者作用域中的变量，就必须使用指针。
2.  **性能和效率**: 当你处理一个非常大的结构体（Struct）时，如果使用值传递，Go 需要复制整个结构体，这会带来很大的内存和性能开销。而如果传递一个指向该结构体的指针，Go 只需复制一个内存地址（通常是8个字节），这会快得多，也更节省内存。
